# 浏览器工作原理

## 发展方向

### 应用程序web化

### web应用移动化

- PWA

### web操作系统化

- Chrome 朝着 SOA 的方向演化，未来很多模块都会以服务的形式提供给上层应用使用
- 在浏览器中引入多种编程语言的支持，比如新支持的 WebAssembly
- 简化渲染流程，使得渲染过程更加直接高效
- 加大对系统设备特性的支持
- 提供对复杂 Web 项目开发的支持

### 意义

- 准确评估 Web 开发项目的可行性
- 从更高维度审视页面

	- 用户体验角度用户体验角度

- 在快节奏的技术迭代中把握本质

	- 脚本执行速度问题

		- 不断修订和更新语言本身 ES6、ES7、ES8，或者 TypeScript 
		- 颠覆性地使用新的语言  WebAssembly

	- 前端模块化开发

		- WebComponents 标准

	- 渲染效率问题

		- 布局方案 LayoutNG、渲染瘦身方案 Slim Paint

## Chrome架构

### 线程 VS 进程

- 线程是不能单独存在的，它是由进程来启动和管理的
- 一个进程就是一个程序的运行实例

	- 启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程

- 线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率
- 进程中的任意一线程执行出错，都会导致整个进程的崩溃
- 线程之间共享进程中的数据
- 当一个进程关闭之后，操作系统会回收进程所占用的内存
- 进程之间的内容相互隔离

	- 进程间通信（IPC）

### 单进程浏览器时代

- 页面线程（页面渲染、展现、JS环境、插件）、网络线程、其他线程
- 不稳定

	- 插件、渲染引擎模块的崩溃也会导致整个浏览器的崩溃

- 不流畅

	- 脚本或者插件会让单进程浏览器变卡顿
	- 页面的内存泄漏

- 不安全

	- 恶意插件、页面脚本

### 多进程浏览器时代

- 早期架构

	- 浏览器主进程

		- 下载资源、管理IPC、显示渲染进程生成的图片

	- 插件进程
	- 渲染进程

		- 解析、渲染、JS执行、合成网页图片
		- 运行在沙箱、不能读写硬盘数据、不能获取操作系统权限

	- 解决不稳定的问题

		- 进程是相互隔离

	- 解决不流畅的问题

		- JavaScript 运行在渲染进程中，只影响当前渲染页面
		- 关闭一个页面，整个渲染进程也会被关闭，解决了浏览器页面的内存泄漏问题

	- 解决不安全的问题

		- 插件进程和渲染进程锁在沙箱里面

- 目前多进程架构

	- 1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程
	- 网络进程、GPU进程

		- 从浏览器进程独立出来

	- 浏览器进程

		- 负责界面显示、用户交互、子进程管理，同时提供存储等功能

	- 渲染进程

		- 将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页
		- 排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中
		- Chrome 会为每个 Tab 标签创建一个渲染进程
		- 渲染进程都是运行在沙箱模式

	- GPU 进程

		- 初衷是为了实现 3D CSS 的效果
		- Chrome 的 UI 界面都选择采用 GPU 来绘制

	- 网络进程

		- 页面的网络资源加载

	- 插件进程

		- 负责插件的运行
		- 因插件易崩溃，所以需要通过插件进程来隔离

- 问题

	- 更高的资源占用
	- 更复杂的体系架构

		- 各模块之间耦合性高、扩展性差

### 未来面向服务的架构

- Services Oriented Architecture，简称SOA
- 各种模块会被重构成独立的服务（Service）在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信
- 访问服务（Service）必须使用定义好的接口，通过 IPC 来通信
- 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务
- chrome基础服务： Profile进程、UI进程、GPU进程、网络进程、文件进程、设备进程、Audio进程、Video进程等
- 弹性架构

	- 在资源受限的设备上，将很多服务整合到一个进程中

## TCP协议

### FP(First Paint) 从页面加载到首次开始绘制的时长

- 网络加载速度

### 页面文件被完整地送达浏览器

- IP（网际协议Internet Protocol）：把数据包送达目的主机

	- 网络层IP头

- UDP：把数据包送达应用程序

	- 基于 IP 之上开发能和应用打交道的协议 传输层
	- 用户数据包协议User Datagram Protocol
	- 端口号（端口号会被装进 UDP 头）
	- UDP 不能保证数据可靠性，但是传输速度却非常快
	- 应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏

- TCP：把数据完整地送达应用程序

	- 解决UDP数据传输丢失、数据包组装还原问题
	- （Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议
	- 重传机制、数据包排序机制
	- 端口号、排序序列号

- 完整的 TCP 连接过程

	- 建立连接

		- 三次握手：建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立

	- 传输数据

		- 接收端需要对每个数据包进行确认操作、数据包校验机制

	- 断开连接

		- 四次挥手

## HTTP 协议

### HTTP 是一种允许浏览器向服务器获取资源的协议，应用层协议

### 浏览器端发起 HTTP 请求流程

- 构建请求
- 查找缓存

	- 浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术

- 准备 IP 地址和端口

	- HTTP 的内容是通过 TCP 的传输数据阶段来实现，第一步和服务器建立TCP连接
	- 域名和 IP 地址做一一映射，DNS（Domain Name System）
	- DNS 数据缓存服务

- 等待 TCP 队列

	- 同一个域名同时最多只能建立 6 个 TCP 连接

- 建立 TCP 连接
- 发送 HTTP 请求

	- 请求行

		- 请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议

	- 请求头

		- 浏览器的基础信息（操作系统、内核）、请求的域名信息、浏览器端的 Cookie 信息

	- 请求体

		- 准备的数据

### 服务器端处理 HTTP 请求流程

- 返回请求

	- 响应行

		- 协议版本和状态码

	- 响应头

		- 服务器自身的信息

			- 服务器生成返回数据的时间
			- 返回的数据类型（JSON、HTML、流媒体等类型）
			- 服务器要在客户端保存的 Cookie 等信息

	- 响应体

		- 包含了 HTML 的实际内容

- 断开连接

	- 关闭 TCP 连接
	- 头信息 Connection:Keep-Alive 保持打开状态 

		- 同一个 TCP 连接发送请求
		- 保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度

- 重定向

	- 301 就是告诉浏览器，我需要重定向到另外一个网址
	- 包含在响应头的 Location 字段中

### 页面资源缓存

- HTTP 响应头

	- 通过响应头中的 Cache-Control 字段来设置是否缓存该资源

		- Cache-Control:Max-age=2000

- 缓存过期

	- 继续发起网络请求，HTTP 请求头

		- If-None-Match:"4f80f-13c-3a1xb12a"
		- 服务器根据 If-None-Match 的值来判断请求的资源是否有更新
		- 没有更新，返回 304 状态码

### 登录状态保持

- Cookie

	- 服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地
	- 发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去

## 从输入 URL 到页面展示

### 用户输入

- 搜索内容

	- 浏览器默认的搜索引擎，合成新的带搜索关键字的 URL

- 请求的 URL

	- 判断输入内容符合 URL 规则，加上协议

### URL 请求过程

- 浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程
- 网络进程发起真正的 URL 请求

	- 查找本地缓存是否缓存了该资源
	- DNS 解析

		- 如果协议是 HTTPS，还需要建立 TLS 连接

	- 利用 IP 地址和服务器建立 TCP 连接

		- 构建请求行、请求头、Cookie等信息

	- 服务器生成响应数据发给网络进程

		- 重定向

			- 会跳转到新的地址继续导航

		- 响应数据类型处理

			- Content-Type告诉浏览器服务器返回的响应体数据是什么类型 
			- text/html HTML 格式

				- 浏览器则会继续进行导航流程，准备渲染

			- application/octet-stream 字节流类型，下载类型

				- 浏览器的下载管理器

### 准备渲染进程

- 每个页面分配一个渲染进程

	- 特殊情况：同一站点，多页面一个进程

		- process-per-site-instance，复用父页面的渲染进程
		- 仅需根域名+协议相同
		- 包含子域名和不同端口

- 文档数据还在网络进程，没开始解析

### 提交文档

- “文档”是指 URL 请求的响应体数据
- “提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”
- 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程
- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面

### 渲染阶段

- 页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画

## 渲染流程

### 构建DOM

- 保存在内存中树状结构
- html通过解析器生成DOM

### 样式计算

- 把 CSS 转换为浏览器能够理解的结构styleSheets

	- document.styleSheets 该结构具备查询和修改功能

- 转换样式表中的属性值，使其标准化
- 计算出 DOM 树中每个节点的具体样式

	- 继承规则

		- 每个 DOM 节点都包含有父节点的样式

	- 样式层叠

		- 如何合并来自多个源的属性值的算法

### 布局阶段

- DOM 树中可见元素的几何位置
- 创建布局树

	- DOM+样式，不可见的节点会被布局树忽略掉

- 布局计算

	- 布局树既是输入内容也是输出内容
	- 下一代布局系统LayoutNG更清晰地分离输入和输出

### 分层

- 为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）
- 如果一个节点没有对应的层，那么这个节点就从属于父节点的图层
- 提升为单独的一个图层

	- 拥有层叠上下文属性的元素会被提升为单独的一层

		- 明确定位属性的元素

			- position:fixed
			- z-index: 2

		- 定义透明属性的元素

			- opacity: 0.5

		- 使用 CSS 滤镜的元素等

			- filter: blue(5px) 

	- 需要剪裁（clip）的地方也会被创建为图层

		- div宽高受限内容过多，剪裁显示部分，出现的滚动条也会被提升为单独的层

### 图层绘制

- 图层的绘制拆分成很多小的绘制指令，指令按照顺序组成一个待绘制列表

### 栅格化（raster）操作

- 绘制操作是由渲染引擎中的合成线程来完成的，绘制列表准备好后主线程会把该绘制列表提交（commit）给合成线程
- 视口 屏幕上页面的可视区域，视口内部包含多个可见图块
- 合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512
- 合成线程会按照视口附近的图块来优先生成位图
- 栅格化，是指将图块转换为位图，图块是栅格化执行的最小单位
- 渲染进程维护了一个栅格化的线程池
- 栅格化过程都会使用 GPU 来加速生成，生成的位图被保存在 GPU 内存

	- 跨进程操作

### 合成和显示

- 所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，该命令提交给浏览器进程
- 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上

### 渲染流水线相关的概念

- 更新了元素的几何属性（重排）

	- 会触发重新布局，重排需要更新完整的渲染流水线，所以开销也是最大的
	- JavaScript 或者 CSS 修改元素的几何位置属性，如宽高

- 更新元素的绘制属性（重绘）

	- 跳过布局，进入了绘制阶段，执行效率会比重排操作要高一些
	-  JavaScript 更改某些元素的背景颜色

- 直接合成阶段

	- 跳过布局和绘制，合成能大大提升绘制效率
	- CSS 的 transform

## JavaScript执行原理

### 创建执行上下文

- js执行全局代码创建执行上下文，在页面的生存周期内全局执行上下文只有一份
- 调用一个函数时，函数体内代码被编译创建函数执行上下文，函数执行结束后上下文被摧毁
- eval函数被编码创建执行上下文

### 执行上下文

- 变量提升（Hoisting）

	- 声明和赋值
	- 在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”
	- 变量被提升后，会给变量设置默认值undefined
	- 实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中

- 编译阶段

	- 执行上下文（Execution context）

		-  JavaScript 执行一段代码时的运行环境
		- 变量环境的对象（Viriable Environment）

			- 保存了变量提升的内容

		- 词法环境（Lexical Environment）

	- 可执行代码

- 执行阶段

### 调用栈

- 用来管理函数调用关系的一种数据结构，管理执行上下文的栈
- 函数调用

	- 存在多个执行上下文（全局、函数内）

- 栈

	- 后进先出

- 调用栈是 JavaScript 引擎追踪函数执行的一个机制
- 利用好调用栈

	- 利用浏览器查看调用栈的信息

		- console.trace() 来输出当前的函数调用关系

	- 栈溢出（Stack Overflow）

		- 入栈的执行上下文超过一定数目

### 作用域

- 作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期
- 变量与函数的可访问范围，控制着变量和函数的可见性和生命周期
- ES6之前

	- 全局作用域、函数作用域、不支持块级作用域
	- 问题

		- 变量容易在不被察觉的情况下被覆盖掉
		- 本应销毁的变量没有被销毁

- ES6 是如何解决变量提升带来的缺陷

	- 引入了 let 和 const 关键字拥有块级作用域
	- let声明的变量存在词法环境，非变量环境
	- 进入块级作用域（if、for等）后，其内部的let/const变量以块的形式压入词法环境栈，和外部词法环境保持独立
	- 如何查找：先沿着词法环境的栈顶向下查询，如果没有查找到，那么继续在变量环境中查找
	- 作用域块执行结束，内部定义的变量从词法环境栈顶弹出

### 作用域链

- 每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer

	- 查找变量现在当前执行上下文查找，没有找到回去outer指向的执行上下文查找

- 查找的链条即作用域链，由词法作用域决定
- 词法作用域

	- 词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符
	- 词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系

- 闭包

	- 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。
	- 比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。无论在哪调用了有foo闭包的内部函数，都会由foo函数的专属背包
	- JavaScript 引擎会沿着“当前执行上下文–>该函数闭包–> 全局执行上下文”的顺序来查找变量
	- 闭包是怎么回收的

		- 如果该闭包会一直使用，那么它可以作为全局变量而存在
		- 但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

### this

- this 是和执行上下文绑定的
- 全局执行上下文中的 this

	- window 对象

- 函数执行上下文中的 this

	- 默认情况下也是指向window
	- 通过函数的 call 、bind和apply方法设置
	- 通过对象调用方法设置

		- 在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window
		- 使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的

	- 通过构造函数中设置

- 问题

	- 嵌套函数中的 this 不会从外层函数中继承

		-  this 没有作用域的限制
		- 声明一个变量 self 用来保存 this
		- ES6 中的箭头函数（不会创建其自身的执行上下文）

	- 普通函数中的 this 默认指向全局对象 window

		- “严格模式”解决 默认this undefined

## JavaScript 的内存机制

### 语言类型

- 在使用之前就需要确认其变量数据类型的称为静态语言
- 在运行过程中需要检查数据类型的语言称为动态语言

### 隐式类型转换

- 支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言

### 数据类型

- Boolean

	- true/false

- Null

	- null

- Undefined

	- 没有赋值的变量、变量提升

- Number

	- -（2^63-1）, 2^63-1

- BigInt

	- 任意精度表示整数

- String
- Symbol

	- 符号类型，唯一不可修改，通常用作Object的key

- Object

	- 对象，属性的集合

- typeof null === ‘object’ 前七种原始类型 最后一个对象类型为引用类型

### 内存空间

- 代码空间

	- 存储可执行代码

- 栈空间

	- 调用栈，存储执行上下文

		- 基本类型变量存在环境变量，栈内存储
		- 引用类型变量将其分配到堆空间存储，产生一个堆中的地址，将该地址存到变量环境中的变量，即保持一个对象的引用地址

- 堆空间
- 栈是维护程序执行上下文的，空间过大会影响上下文切换效率，因此栈空间不会过大，主要存放原始类型的小数据，引用类型占用空间大存在堆中，缺点是分配内存和回收内存占用时间
- 原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址
- 闭包

	- 词法分析，内部函数引用外部函数变量
	- 将引用的变量用闭包对象（closure(foo)）的形式存储到堆中

### 垃圾回收

- 手动回收

	- 何时分配内存、何时销毁内存都是由代码控制的

- 自动回收

	- 垃圾回收器来释放

- 栈中的垃圾数据

	- 记录当前执行状态的指针（称为 ESP）
	- ESP 下移,销毁执行过的函数保存在栈中的执行上下文

		- 虽然该函数执行上下文还保存在栈内存中，但是已是无效内存
		- 再次调用另外一个函数会覆盖

- 堆中的垃圾数据

	- JavaScript 中的垃圾回收器，V8

- 代际假说（The Generational Hypothesis）

	- 大部分对象在内存中存在的时间很短
	- 不死的对象，会活得更久

- 垃圾回收器的工作流程

	- 标记空间中活动对象和非活动对象

		- 活动对象就是还在使用的对象

	- 回收非活动对象所占据的内存
	- 内存整理

		- 大量不连续空间，内存碎片整理

- V8

	- 新生代区域

		- 生存时间短的对象
		- 通常只支持 1～8M 的容量

			- 大多数小的对象

		- 副垃圾回收器

			- Scavenge 算法

				- 新生代空间对半划分为两个区域

					- 对象区域
					- 空闲区域

				- 对象区域快被写满，执行一次垃圾清理操作
				- 存活的对象复制到空闲区域中有序地排列（内存整理）
				- 对象区域与空闲区域进行角色翻转，完成了垃圾对象的回收
				- 复制操作需要时间成本，一般新生区的空间会被设置得比较小

		- 新生区的空间不大，容易被存活的对象装满

			- 对象晋升策略

				- 经过两次垃圾回收依然还存活的对象移动到老生区

	- 老生代区域

		- 生存时间久的对象

			- 新生区中晋升的对象

		- 占用空间大

			- 一些大的对象会直接被分配

		- 主垃圾回收器

			- 标记 - 清除（Mark-Sweep）的算法

				- 标记过程阶段

					- 从一组根元素递归遍历这组根元素，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据

				- 垃圾的清除过程

					- 会产生大量不连续的内存碎片
					- 碎片过多会导致大对象无法分配到足够的连续内存

			- 标记 - 整理（Mark-Compact）

				- 不是直接对可回收对象进行清理
				- 让所有存活的对象都向一端移动，直接清理掉端边界以外的内存

	- 全停顿（Stop-The-World）

		- 执行垃圾回收算法，要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行
		- 新生代的垃圾回收中空间较小、存活对象少，影响不大
		- 老生代可能占用主线程时间过久

			- 增量标记（Incremental Marking）算法

				- 将标记过程分为一个个的子标记过程
				- 让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成

### V8

- 编译器和解释器

	- 编译型语言

		- 程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，程序运行不需要再次重新编译
		- 源代码 --》 词法分析、语法分析--》AST --》词义分析 --》中间代码 --》代码优化 --》二进制文件--》直接执行

	- 解释型语言

		- 每次运行时都需要通过解释器对程序进行动态解释和执行
		- 源代码 --》 词法分析、语法分析--》AST --》词义分析 --》字节码 --》  直接执行

- 执行一段 JavaScript 

	- 生成抽象语法树（AST）和执行上下文

		- 编译器或者解释器理解不了高级语言，理解AST
		- AST一种数据结构，看成代码的结构化

			- Babel
			- ESLint

		- 生成AST 

			- 分词（tokenize），词法分析

				- 关键字、标识符、赋值、字符串等

			- 解析（parse），语法分析

				- 词token根据语法规则转换为AST

	- 生成字节码

		- 解释器 Ignition(点火器) 

			- 根据 AST 生成字节码，并解释执行字节码
			- 最初直接转机器码，效率高但是内存消耗大、占用问题
			- 字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行

	- 执行代码

		- 第一次执行的字节码，解释器 Ignition 会逐条解释执行
		- 热点代码（HotSpot）--重复执行多次，后台的编译器 TurboFan（涡轮增压）把其编译为高效的机器码 ，提升了代码的执行效率

	- 字节码配合解释器和编译器

		- 即时编译（JIT）

	- 性能优化

		- 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互
		- 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程
		- 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存

## 页面循环系统

### 事件循环系统

- 在线程运行过程中，能接受并执行新的任务，就需要采用事件循环机制

	- 循环机制，线程循环执行
	- 引入事件，线程暂停等待事件完成继续运行

- 处理其他线程发送的消息

	- 消息队列

		- 添加任务添加到队列的尾部；取出任务从队列头部去取

- 处理其他进程发送过来的任务

	- chrome渲染进程中有个io线程用来接收其他进程的消息

- 消息队列中任务类型

	- 内部消息类型如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等
	- 与页面相关的事件如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等

- 如何安全退出

	- 页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志

- 页面使用单线程的缺点

	- 如何处理高优先级的任务

		- 如监控 DOM 节点的变化
		- 同步通知的话如果DOM 变化非常频繁，影响当前任务的执行效率
		- 异步的消息事件，影响到监控的实时性
		- 微任务应用而生

			- 权衡效率和实时性
			- 消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列
			- 执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题
			- 等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题

	- 解决单个任务执行时长过久

		- 通过回调功能来规避

- chrome “Performance”标签

	- start porfiling and load page”来记录整个页面加载过程中的事件执行情况

### setTimeout

- 延时队列（另一个消息队列），延迟执行的任务列表

	- 定时器和 Chromium 内部延迟任务
	- DelayedIncomingQueue
	- 执行时机：处理完消息队列中的一个任务之后，执行 ProcessDelayTask 函数
	- ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，依次执行到期任务

- 设置一个定时器，JavaScript 引擎会返回一个定时器的 ID

	- 还没有被执行可以取消clearTimeout
	- 实现就是delayed_incoming_queue 延迟队列中通过ID找到删除

- 注意事项

	- 如果当前任务执行时间过久，会影延迟到期定时器任务的执行
	- 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒

		- 定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了

	- 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒
	- 延时执行时间有最大值：2147483647 毫秒（大约 24.8 天）
	- 使用 setTimeout 设置的回调函数中的 this 不符合直觉

		- 匿名函数执行（箭头函数）
		- bind

### XMLHttpRequest

- 回调函数

	- 将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数
	- 同步回调和异步回调
	- 系统调用栈

		- chrome://tracing/
		-  Performance页面查看

- XMLHttpRequest 运作机制

	- 创建 XMLHttpRequest 对象
	- 为 xhr 对象注册回调函数

		- ontimeout

			- 监控超时请求

		- onerror

			- 监控出错信息

		- onreadystatechange

			- 监控后台请求过程中的状态

				- HTTP 头加载完成的消息
				- HTTP 响应体消息
				- 数据加载完成的消息等

		- 配置基础的请求信息

			- open 接口配置请求的地址、请求方法（是 get 还是 post）和请求方式（同步还是异步请求）等基础的请求信息
			- xhr 内部属性类配置一些其他可选的请求信息

				- timeout超时时间
				- responseType服务器返回的格式

					- “ ” 和“text”

						- UTF-16字符串文本

					- “json”

						- JavaScript对象

					- “document”

						- Dom对象

					- “blob”

						- 包含二进制数据的Blob对象

					- “arraybuffer”

						- 包含二进制的JavaScript ArrayBuffer

				- setRequestHeader 专用请求头属性

	- 发起请求

		- xhr.send

	- 渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数

- 使用过程中的“坑”

	- 跨域问题
	- HTTPS 混合内容的问题

		-  HTTPS 页面中包含了不符合 HTTPS 安全要求的内容
		- 比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容

### 宏任务和微任务

- 宏任务

	- 渲染事件（如解析 DOM、计算布局、绘制）
	- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）
	- JavaScript 脚本执行事件
	- 网络请求完成、文件读写完成事件
	- 宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，高实时性的需求就不太符合

- 微任务

	- 在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列，当前宏任务执行产生的多个微任务保存到队列中
	- 需要异步执行的函数

		- MutationObserver 监控某个 DOM 节点，节点变化产生微任务

			- 监听 DOM 变化方法演变

				- 早期页面使用 setTimeout 或者 setInterval 来定时检测

					- 时间间隔设置过长，DOM 变化响应不够及
					- 时间间隔设置过短，又会浪费很多无用的工作量，页面变得低效

				- 2000 年引入了 Mutation Event

					- 观察者的设计模式，同步回调

						- 严重的性能问题较大的性能开销

				- DOM4 开始MutationObserver

					-  将响应函数改成异步调用

						- 多次 DOM 变化后，一次触发异步调用
						- 使用一个数据结构来记录这期间所有的 DOM 变化

					- 保持消息通知的及时性

						- 微任务

		- 使用 Promise，resolve和reject时产生

	- 执行时机是在主函数执行结束之后、当前宏任务结束之前

		- 当前宏任务中的 JavaScript 快执行完成，JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列
		- 执行微任务的时间点称为检查点
		- 产生了新的微任务，同样会将该微任务添加到微任务队列中

- 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列
- 微任务的执行时长会影响到当前宏任务的时长
- 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行

### promise

- 封装异步代码，让处理流程变得线性

	- 重点关注的是输入内容（请求信息）和输出内容（回复信息）

- 新的问题：回调地狱

	- 消灭嵌套调用

		- Promise 实现了回调函数的延时绑定
		- 需要将回调函数 onResolve 的返回值穿透到最外层

	- 合并多个任务的错误处理

		- Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止

- Promise 与微任务

	- 由于 Promise 采用了回调函数延迟绑定技术，所以在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行
	- 微任务来实现延时执行

### async/await

- ES7 引入了 async/await，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力
- 生成器（Generator） VS 协程（Coroutine）

	- 生成器函数内部执行代码遇到yield关键字，js引擎返回关键字后面的内容给外部，并暂停该函数的执行
	- 外部函数可以通过next方法恢复函数的执行
	- 协程是一种比线程更加轻量级的存在，可以把协程看成是跑在线程上的任务
	- 一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程
	- 协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）
	- 切换协程的调用栈

		- gen协程和主协程交互进行（非并发），通过yield和gen.next配合完成
		- 切换过程JS引擎会保存之前协程的调用栈信息

	- JS中生成器就是协程的一种实现方式

- async

	- 通过异步执行并隐式返回 Promise 作为结果的函数

- await

	- 默认创建一个Promise对象，创建过程中js引擎将该任务提交到微任务列表
	- 然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 创建的promise_ 对象返回给父协程
	- 父协程要做的一件事是调用 promise_.then 来监控 promise 状态的改变
	- 父协程执行结束前进入微任务检查点执行微任务队列，触发promise.then中的回调函数，将主线程控制器交给子协程，同时将返回值传给该协程

## 浏览器中的页面

### chrome开发者工具

- 面板

	- Elements

		- DOM结构、CSS样式，用于测试页面布局和设计页面

	- Console

		- JavaScript Shell，能与页面中JavaScript对象交互

	- Sources

		- 查看web应用加载的所有文件
		- 编辑CSS和JS文件内容
		- 将打乱的CSS文件或JS文件格式化
		- 支持JS调试
		- 设置工作区将更改的文件保存到本地文件夹中

	- NetWork

		- 请求内容列表，查看请求行、请求头、请求体、时间线以及网络请求瀑布图等

			- 控制器

				- 开始 / 暂停抓包
				- “全局搜索”按钮
				- Disable cache禁止从 Cache 中加载资源， 调试web应用
				- Online 按钮 模拟 2G/3G

			- 过滤器

				- 筛选想要的文件类型

			- 抓图信息

				- 分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况
				- 勾选面板上的“Capture screenshots”即可启用屏幕截图

			- 时间线

				- 展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系
				- 多条竖线堆叠在一起，那说明这些资源被同时被加载

			- 详细列表

				- 资源从发起请求到完成请求这中间所有过程的状态

					- 列表的属性

						- Name、Status、Type、Initiator 

					- 详细信息

						- 请求行、请求头、响应行、响应头和响应体

					- 单个资源的时间线

						- Timing

							- Queuing（排队状态）

								- 页面中的资源是有优先级

									- CSS、HTML、JavaScript 等都是页面中的核心文件，所以优先级最高
									- 图片、视频、音频这类资源就不是核心资源，优先级就比较低

								- 浏览器会为每个域名最多维护 6 个 TCP 连接
								- 网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束

							- Stalled（停滞）

								- 发起连接之前，还有一些原因可能导致连接过程被推迟

							- Proxy Negotiation

								- 使用了代理服务器，表示代理服务器连接协商所用的时间

							- Initial connection/SSL 

								- 建立 TCP 连接所花费的时间
								- 使用了 HTTPS 协议，SSL 握手时间（协商一些加密信息）

							- Request sent

								- 准备请求数据，并将其发送给网络，不需要判断服务器是否接收到

							- Waiting (TTFB第一字节时间)

								- 反映服务端响应速度的重要指标

							- Content Download

								- 从第一字节时间到接收到全部响应数据所用的时间

					- 优化时间线上耗时项

						- 排队（Queuing）时间过久

							- 域名分片技术--1 个站点下面的资源放在多个域名下面
							- 站点升级到 HTTP2，没有6个TCP连接限制

						- 第一字节时间（TTFB）时间过久

							- 服务器生成页面数据的时间过久

								- 增加各种缓存的技术

							- 网络的原因（低带宽、网络运营商不同）

								- CDN 来缓存一些静态文件

							- 发送请求头时带上了多余的用户信息（不必要的cookie）

						- Content Download 时间过久

							- 字节数太多

								- 需要减少文件大小，压缩、去掉源码中不必要的注释等方法

			- 下载信息概要

				-  DOMContentLoaded

					- 这个事件发生后，说明页面已经构建好 DOM 
					- 构建 DOM 所需要的 HTML 文件、JavaScript 文件、CSS 文件都已经下载完成了

				- Load

					- 浏览器已经加载了所有的资源（图像、样式表等）

	- Performance

		- 记录和查看Web应用生命周期的各种事件，分析执行过程中影响性能的要点

	- Memory

		- 查看运行时JS占用堆内存情况，追踪是否存在内存泄漏

	- Application

		- 查看Web应用数据存储情况；PWA的基础数据；IndexedDB；Web SQL; 本地和回话存储Cookie；应用程序缓存；图像、字体和样式表等

	- Security

		- 当前页面基础安全信息

	- Audits

		- 对当前网页进行网络利用情况、网页性能方面的诊断

	- Layers

		- 渲染过程中分层信息

*XMind: ZEN - Trial Version*
